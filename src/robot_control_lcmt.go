// THIS IS AN AUTOMATICALLY GENERATED FILE.  DO NOT MODIFY
// BY HAND!!
//
// Generated by lcm-gen

package main

import (
	"encoding/binary"
	"fmt"
	"math"
	"math/bits"
)

const _ = math.Pi
const _ = bits.UintSize

const robot_control_lcmt_Fingerprint uint64 = 0x1bf19df40f7f6501

type ExlcmRobotControlLcmt struct {
	ControlMode int32      `json:"control_mode"`
	GaitType    int32      `json:"gait_type"`
	VDes        [3]float32 `json:"v_des"`
	StepHeight  float32    `json:"step_height"`
	RpyDes      [3]float32 `json:"rpy_des"`
}

// Copy creates a deep copy
// TODO: fix the fugly x and p names...
func (x *ExlcmRobotControlLcmt) Copy() (p ExlcmRobotControlLcmt) {
	p.ControlMode = x.ControlMode

	p.GaitType = x.GaitType

	for i0 := 0; i0 < 3; i0++ {
		p.VDes[i0] = x.VDes[i0]
	}

	p.StepHeight = x.StepHeight

	for i0 := 0; i0 < 3; i0++ {
		p.RpyDes[i0] = x.RpyDes[i0]
	}

	return
}

// Encode encodes a message (fingerprint & data) into binary form
//
// returns Encoded data or error
func (p *ExlcmRobotControlLcmt) Encode() (data []byte, err error) {
	var size int
	if size, err = p.Size(); err != nil {
		return
	}

	data = make([]byte, 8+size)
	binary.BigEndian.PutUint64(data, ExlcmRobotControlLcmt_Fingerprint())

	var d []byte
	if d, err = p.MarshalBinary(); err != nil {
		return
	}

	if copied := copy(data[8:], d); copied != size {
		return []byte{},
			fmt.Errorf("Encoding error, buffer not filled (%v != %v)", copied, size)
	}
	return
}

// MarshalBinary implements the BinaryMarshaller interface
func (p *ExlcmRobotControlLcmt) MarshalBinary() (data []byte, err error) {
	var size int
	if size, err = p.Size(); err != nil {
		return
	}

	data = make([]byte, size)
	offset := 0

	// LCM struct name: control_mode
	binary.BigEndian.PutUint32(data[offset:],
		uint32(p.ControlMode))
	offset += 4

	// LCM struct name: gait_type
	binary.BigEndian.PutUint32(data[offset:],
		uint32(p.GaitType))
	offset += 4

	// LCM struct name: v_des
	for i0 := 0; i0 < 3; i0++ {
		binary.BigEndian.PutUint32(data[offset:],
			math.Float32bits(p.VDes[i0]))
		offset += 4
	}

	// LCM struct name: step_height
	binary.BigEndian.PutUint32(data[offset:],
		math.Float32bits(p.StepHeight))
	offset += 4

	// LCM struct name: rpy_des
	for i0 := 0; i0 < 3; i0++ {
		binary.BigEndian.PutUint32(data[offset:],
			math.Float32bits(p.RpyDes[i0]))
		offset += 4
	}

	return
}

// Decode decodes a message (fingerprint & data) from binary form
// and verifies that the fingerprint match the expected
//
// param data The buffer containing the encoded message
// returns Error
func (p *ExlcmRobotControlLcmt) Decode(data []byte) (err error) {
	length := len(data)
	if length < 8 {
		return fmt.Errorf("Missing fingerprint in buffer")
	}

	if fp := binary.BigEndian.Uint64(data[:8]); fp != ExlcmRobotControlLcmt_Fingerprint() {
		return fmt.Errorf("Fingerprints does not match (got %x expected %x)",
			fp, ExlcmRobotControlLcmt_Fingerprint())
	}

	if err = p.UnmarshalBinary(data[8:]); err != nil {
		return
	}

	length -= 8
	var size int
	if size, err = p.Size(); err != nil {
		return
	}
	if length != size {
		return fmt.Errorf("Missing data in buffer (size missmatch, got %v expected %v)",
			length, size)
	}

	return
}

// UnmarshalBinary implements the BinaryUnmarshaler interface
func (p *ExlcmRobotControlLcmt) UnmarshalBinary(data []byte) (err error) {
	offset := 0

	p.ControlMode = int32(binary.BigEndian.Uint32(data[offset:]))
	offset += 4

	p.GaitType = int32(binary.BigEndian.Uint32(data[offset:]))
	offset += 4

	for i0 := 0; i0 < 3; i0++ {
		p.VDes[i0] = math.Float32frombits(binary.BigEndian.Uint32(data[offset:]))
		offset += 4
	}

	p.StepHeight = math.Float32frombits(binary.BigEndian.Uint32(data[offset:]))
	offset += 4

	for i0 := 0; i0 < 3; i0++ {
		p.RpyDes[i0] = math.Float32frombits(binary.BigEndian.Uint32(data[offset:]))
		offset += 4
	}

	return
}

// Fingerprint generates the LCM fingerprint value for this message
func ExlcmRobotControlLcmt_Fingerprint(path ...uint64) uint64 {
	for _, v := range path {
		if v == robot_control_lcmt_Fingerprint {
			return 0
		}
	}

	path = append(path, robot_control_lcmt_Fingerprint)
	return bits.RotateLeft64(robot_control_lcmt_Fingerprint, 1)
}

// Size returns the size of this message in bytes
func (p *ExlcmRobotControlLcmt) Size() (size int, err error) {

	size += 4 // p.ControlMode

	size += 4 // p.GaitType

	for i0 := 0; i0 < 3; i0++ {
		size += 4 // p.VDes
	}

	size += 4 // p.StepHeight

	for i0 := 0; i0 < 3; i0++ {
		size += 4 // p.RpyDes
	}

	return
}
